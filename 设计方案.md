# 全系统功能核查与设计方案

> **设计人员**: AI 开发助手  
> **验收人员**: 07  
> **版本**: v7.2（第二轮审核整改版）  
> **日期**: 2026-02-25  
> **审核状态**: 第二轮审核 3 项缺陷 + 5 项疏漏 + 4 项文档问题已全部修正  
> **变更说明**: v6.0 全面核查 → v6.1 用户体系修正 → v6.2 第一轮测试 → v6.3 第二轮测试 → v6.4 定时任务重构 → v7.0 审核整改 → v7.1 业务确认修正 → **v7.2 第二轮审核整改：修正 DES-8 伪代码 status 值、补全发布接口方案、拆分 SEC-5、纳入审核确认的枚举值、补充 ARCH-2 单进程约束/SEC-7 多标签页协调/DES-2 边界值处理**
> **本版核心变化**: ① 纳入审核已确认的 UserRole 枚举值（MANAGER="manager"），SEC-4 消除不确定性可直接实施；② DES-8 修正 status 值 + 补全发布接口方案 + 存量文章迁移 + 审计追溯；③ SEC-5 拆分为 5a(已完成)+5b(待实施)；④ ARCH-2 标注单进程约束；⑤ SEC-7 增加跨标签页协调；⑥ DES-2 增强边界值处理；⑦ 工时增加联调测试

---

## 〇、沟通记录

| 日期 | 沟通内容 | 结论 | 备注 |
|------|---------|------|------|
| 2026-02-25 | 07 要求全面核查系统功能 | 建立核查清单 + 一键测试脚本 | 对不合理/赘余/无法实现的功能全部列出 |
| 2026-02-25 | 07 指出经理账号已改为 `manager`，且有组长角色 `wjzu` | 深入重新探查用户体系，发现致命 bug | 设计人员初次探查不够深入，已修正 |
| 2026-02-25 | 07 在服务器运行一键测试脚本，首轮结果 87 项 71 通过 16 失败 | 分析 16 项失败原因，区分测试脚本 bug 和真实系统 bug | 修正测试参数名、发现 1 个 500 错误真实 bug |
| 2026-02-25 | 07 确认 Google Ads 已改用服务账号，不再使用 OAuth | OAuth 模块标记为弃用 | 后续需清理 Google OAuth 相关代码 |
| 2026-02-25 | 第二轮测试 85 项 81 通过（95.3%），剩余 3 失败 1 警告 | 发现露出审核列表死锁 bug（DES-8），确认 platform-summary 500 仍存在 | 测试脚本再次修正 |
| 2026-02-25 | 第三轮测试 85 项 82 通过（96.5%），仅 1 FAIL 2 WARN | 确认 v5.4 遗留 7/9 项已实施（D1-D6,P1-P2），2 项待确认 | 所有代码已有注释标记修复编号 |
| 2026-02-25 | 07 反馈 MCC 同步一直显示"找不到"，CNY 账号需重新拉取 | 修复错误信息吞没问题，创建诊断脚本 | 需在服务器运行诊断脚本确定具体原因 |
| 2026-02-25 | 07 要求 3.1 前补齐所有 MCC 数据，每天 04:00 同步昨日，今日手动触发 | 重构定时任务：删除 DES-5/CODE-4，新增 05:00 自动补齐（CNY优先, 3MCCx10天, 配额感知） | v6.4 已提交推送 |
| **2026-02-25** | **07 初步验收通过，审核人员出具验收审核报告，发现 v6.4 遗漏 14 项风险** | **设计方案覆盖率从 65% 提升，补充全部遗漏项的修复方案** | **v7.0 审核整改版：针对 SEC-5~12、ARCH-1~6 逐项编写问题阐释+解决思路+最终方案；修正原方案中 SEC-4 枚举值未确认、DES-8 权限函数设计不当等问题** |
| **2026-02-25** | **07 回复 6 个业务确认问题，DES-8 方案需大改** | **根据 07 回复全面修正方案至 v7.1** | **关键修正：① DES-8 审核人仅 wj07+wj02，3-4月审核后发布、之后自审即发；② 组长审核仅本组；③ jy/yz 组未来可能用露出功能，需可扩展；④ 密码重置改为经理指定；⑤ Developer Token 不可轮换；⑥ SECRET_KEY 待 07 服务器检查后确认** |
| **2026-02-25** | **07 在服务器检查 SECRET_KEY，确认为默认不安全值** | **SEC-5a 服务器密钥已修复 ✅** | **07 已在服务器完成：SECRET_KEY + REFRESH_SECRET_KEY 替换为安全随机值 → 重启服务 → health 检查通过** |
| **2026-02-25** | **第二轮审核报告：v7.1 方案发现 3 项缺陷 + 5 项疏漏 + 4 项文档问题** | **全部修正，升级为 v7.2** | **关键收获：审核代为确认 UserRole 枚举值 MANAGER="manager"（SEC-4 可直接实施）；修正 DES-8 伪代码 status 值；补全发布接口方案；拆分 SEC-5a/5b；标注 ARCH-2 单进程约束；增强 DES-2 边界值；增加联调测试工时** |
| | | | |

---

## 一、v7.0 整改总览

### 1.1 审核报告核心结论

| 项目 | 结果 |
|------|------|
| 审核结论 | ⚠️ 有条件通过 |
| v6.4 已发现问题准确率 | 100%（17 项全部交叉验证通过） |
| v6.4 覆盖率 | 约 65%（遗漏 14 项风险） |
| 本次需补充修复项 | 8 项安全/架构风险（SEC-5~12）+ 6 项数据完整性风险（ARCH-1~6） |
| 原方案需修正项 | SEC-4 枚举值确认、DES-8 权限函数重设计、SEC-2/3 范围扩大、DES-1 四层而非三层 |

### 1.2 整改项全景表

| 序号 | 编号 | 问题 | 来源 | 严重程度 | 优先级 | 状态 |
|------|------|------|------|---------|--------|------|
| 1 | SEC-4 | mcc.py 硬编码 wenjun123（枚举值已确认 ✅） | v6.4 已列（v7.2 枚举已确认） | 💀 致命 | P0 | 🟢 方案就绪，可直接实施 |
| 2a | SEC-5a | SECRET_KEY 服务器密钥替换 | **审核新发现** | 🔴 严重 | P0 | ✅ **已修复**（07 已在服务器配置安全密钥并重启） |
| 2b | SEC-5b | 启动时校验 SECRET_KEY 非默认值（代码层面治本） | **审核新发现** | 🟠 中等 | P1 | 🔵 方案已编写 |
| 3 | SEC-1 | 默认密码硬编码 | v6.4 已列 | 🔴 严重 | P0 | 🔵 方案已编写 |
| 4 | DES-8 | 露出审核死锁 + 分阶段发布策略（v7.1 重写） | v6.4 已列（v7.1 根据 07 业务完全重设计） | 🔴 严重 | P0 | 🟢 方案已根据 07 确认修正 |
| 5 | DES-2/CODE-5 | platform-summary 500 数据类型错误 | v6.4 已列 | 🔴 严重 | P0 | 🔵 方案已编写 |
| 6 | SEC-7 | Access Token 存储在 localStorage | **审核新发现** | 🔴 严重 | P1 | 🔵 方案已编写 |
| 7 | SEC-6 | 生产环境泄露完整堆栈 | **审核新发现** | 🟠 中等 | P1 | 🔵 方案已编写 |
| 8 | SEC-2/SEC-3 | 敏感 Token 泄露（范围扩大） | v6.4 已列（范围补充） | 🔴 严重 | P1 | 🔵 方案已编写 |
| 9 | ARCH-2 | 定时任务无并发控制 | **审核新发现** | 🔴 严重 | P1 | 🔵 方案已编写 |
| 10 | SEC-8 | 无数据库备份机制 | **审核新发现** | 🟠 中等 | P1 | 🔵 方案已编写 |
| 11 | SEC-12 | 启动时无关键配置校验 | **审核新发现** | 🟠 中等 | P2 | 🔵 方案已编写 |
| 12 | DES-6 | 露出功能权限设计不合理 | v6.4 已列 | 🟠 中等 | P2 | 🔵 方案已编写 |
| 13 | DES-7 | Google OAuth 模块已弃用 | v6.4 已列 | 🟠 中等 | P2 | 🔵 方案已编写 |
| 14 | ARCH-1 | 无数据库迁移管理系统 | **审核新发现** | 🔴 严重 | P2 | 🔵 方案已编写 |
| 15 | ARCH-3 | 历史数据同步无日期范围上限 | **审核新发现** | 🟠 中等 | P2 | 🔵 方案已编写 |
| 16 | SEC-9 | 数据同步接口缺少速率限制 | **审核新发现** | 🟡 轻微 | P2 | 🔵 方案已编写 |
| 17 | SEC-10 | Token 刷新接口无速率限制 | **审核新发现** | 🟡 轻微 | P3 | 🔵 方案已编写 |
| 18 | SEC-11 | 文件上传文件名未清理 | **审核新发现** | 🟡 轻微 | P3 | 🔵 方案已编写 |
| 19 | ARCH-4 | API 配额耗尽无自动恢复 | **审核新发现** | 🟠 中等 | P3 | 🔵 方案已编写 |
| 20 | ARCH-5 | 大量查询使用 .all() 无分页 | **审核新发现** | 🟡 轻微 | P3 | 🔵 方案已编写 |
| 21 | ARCH-6 | 多步数据库操作缺乏事务保护 | **审核新发现** | 🟡 轻微 | P3 | 🔵 方案已编写 |
| 22 | DES-1 | CORS 四重冗余（审核修正为四层） | v6.4 已列（审核修正） | 🟠 中等 | P2 | 🔵 方案已编写 |
| 23 | DES-3 | 废弃端点未清理 | v6.4 已列 | 🟢 轻微 | P2 | 🔵 方案已编写 |
| 24 | DES-4 | OpenAI 配置残留 | v6.4 已列 | 🟢 轻微 | P3 | 🔵 方案已编写 |
| 25 | CODE-1 | 脚本重复代码 | v6.4 已列 | 🟠 中等 | P2 | 🔵 方案已编写 |
| 26 | CODE-2 | CORS 配置重复 | v6.4 已列 | 🟢 轻微 | P2 | 🔵 方案已编写 |
| 27 | 赘余文件 | 80+ 赘余文件清理 | v6.4 已列 | 🟠 中等 | P2 | 🔵 方案已编写 |

---

## 二、P0 级修复方案（阻塞上线，必须立即处理）

### 2.1 SEC-4：mcc.py 硬编码 wenjun123 + 枚举值确认

#### 问题阐释

`mcc.py:1327` 中权限检查使用硬编码 `current_user.username != "wenjun123"` 来判断是否为管理员，但经理账号已通过 `migrate_teams.py` 从 `wenjun123` 迁移为 `manager`。这导致经理用 `manager` 账号登录后无法上传全局服务账号配置（被 403 拦截）。

审核报告额外发现：当前权限检查条件中使用的是字符串 `"admin"` 而非 `UserRole.MANAGER` 枚举，如果修复时直接写 `current_user.role != UserRole.MANAGER`，必须先确认 `UserRole` 枚举中 MANAGER 角色对应的实际字符串值，否则修复后仍然无法通过权限检查。

**影响范围**（含审核报告补充）：

| 文件 | 行号 | 当前问题 | 影响 |
|------|------|---------|------|
| `app/api/mcc.py` | 1327 | `current_user.username != "wenjun123"` | 经理无法上传服务账号 |
| `app/api/mcc.py` | 1327 | `current_user.role != "admin"` 使用字符串而非枚举 | 角色比较不安全 |
| `app/config.py` | 82 | `MANAGER_USERNAME: str = "wenjun123"` | 配置不一致 |
| `scripts/init_users.py` | 21,29 | 创建 `wenjun123` | 初始化用户名错误 |
| `scripts/update_users.py` | 34,40 | 查询 `wenjun123` | 更新脚本目标错误 |
| `scripts/migrate_users.py` | 24,27 | 创建 `wenjun123` | 已过时 |
| `scripts/test_wj08.py` | 15 | `MANAGER_USERNAME = "wenjun123"` | 已过时 |
| 其他 5+ 文件 | 多处 | 含 `wenjun123` 字符串 | 审核报告确认共 11 个文件 |

#### UserRole 枚举值（第二轮审核已代为确认 ✅）

| 枚举常量 | 字符串值 | 来源 |
|---------|---------|------|
| `UserRole.MANAGER` | `"manager"` | `backend/app/models/user.py:13` |
| `UserRole.LEADER` | `"leader"` | `backend/app/models/user.py:14` |
| `UserRole.MEMBER` | `"member"` | `backend/app/models/user.py:15` |
| `UserRole.EMPLOYEE` | `"employee"` | `backend/app/models/user.py:16` |

> `UserRole` 继承自 `str, enum.Enum`，因此 `UserRole.MANAGER == "manager"` 为 `True`，直接使用枚举比较是安全的。
> **关键发现**：`mcc.py:1327` 当前代码中的 `current_user.role != "admin"` 里的 `"admin"` **不是** UserRole 中的任何合法值，因此该条件**永远为 True**，权限判断完全依赖 `username != "wenjun123"` 这一条件。修复时应将整个 `if` 条件替换为 `current_user.role != UserRole.MANAGER`。

#### 解决思路

1. ~~先确认 UserRole 枚举定义~~ → ✅ **已由第二轮审核代为确认**：`UserRole.MANAGER = "manager"`（小写），无大小写问题
2. **统一使用枚举比较**：所有角色判断改为 `current_user.role == UserRole.MANAGER`，杜绝字符串比较
3. **全局搜索 wenjun123**：覆盖审核报告确认的 11 个文件，逐一修改或标记删除
4. **数据库检查**：确认服务器数据库中是否仍有 `wenjun123` 用户记录，如有需做数据迁移

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | ~~确认枚举~~ | ~~`app/models/user.py`~~ | ✅ 已确认：`UserRole.MANAGER = "manager"`，继承 `str, Enum`，可直接比较 |
| 2 | 修复权限检查 | `app/api/mcc.py:1327` | 将 `current_user.role != "admin" and current_user.username != "wenjun123"` **整个替换为** `current_user.role != UserRole.MANAGER`（注意添加 `from app.models.user import UserRole`） |
| 3 | 修复配置 | `app/config.py:82` | `MANAGER_USERNAME: str = "manager"` |
| 4 | 修复初始化脚本 | `scripts/init_users.py` | 将 `wenjun123` 改为 `manager` |
| 5 | 修复更新脚本 | `scripts/update_users.py` | 将 `wenjun123` 改为 `manager` |
| 6 | 删除过时脚本 | `scripts/migrate_users.py`, `scripts/test_wj08.py` | 已过时，直接删除 |
| 7 | 全局搜索清理 | 其余含 `wenjun123` 的文件 | 逐一修改为 `manager` 或删除文件 |
| 8 | 数据库验证 | 服务器数据库 | 执行 SQL 查询确认 `wenjun123` 是否已迁移；若未迁移，补执行 `migrate_teams.py` |

**蝴蝶效应预判**（v7.2 更新：枚举值已确认，大小写不确定性已消除）：

```
修复 mcc.py:1327
    ↓ UserRole.MANAGER = "manager"（已确认，无大小写问题）
    → 直接用 UserRole.MANAGER 比较即可 ✓
    ↓ 修改 init_users.py
    → 新部署时初始化正确，但已部署的数据库不受影响
    → 需在服务器执行 SQL 确认 wenjun123 是否已迁移
    ↓ 删除 migrate_users.py / test_wj08.py
    → 需先确认无其他脚本引用这些文件（全局搜索文件名）
```

**预估工作量**：1.5h（枚举值已确认，减少 0.5h 调查时间）

---

### 2.2 SEC-5：SECRET_KEY 使用不安全默认值（审核新发现）（v7.1 补充说明）

#### 问题阐释

> **给 07 的通俗解释**：SECRET_KEY 是后端给登录凭证（JWT Token）"签字画押"用的密钥，类似于公司公章的印模。代码里写了一个占位默认值 `"your-secret-key-change-in-production"`，如果服务器没有通过环境变量替换成一个安全的随机字符串，就相当于公章的印模是公开的——任何人都能伪造"盖了章"的登录凭证，冒充任何用户（包括经理）登录系统。
>
> **07 需要在服务器上执行以下命令检查**：
> ```bash
> cat ~/Google-Data-Analysis/backend/.env | grep SECRET_KEY
> ```
> - 若输出中 `SECRET_KEY=` 后面是一串随机字符（如 `abc123xyz...`），说明已配置安全值 ✅
> - 若输出为 `SECRET_KEY=your-secret-key-change-in-production` 或无此行，说明**未配置，存在严重风险** ❌

`backend/app/config.py:59` 中 `SECRET_KEY` 的默认值为 `"your-secret-key-change-in-production"`，这是一个公开的占位字符串。若生产环境未通过环境变量覆盖该值，所有 JWT Token 都基于这个已知密钥签名，意味着：

- 任何人都可以使用该密钥伪造任意用户的 JWT Token
- 攻击者可冒充经理账号执行任何操作（包括上传服务账号、修改 MCC 配置等）
- 系统的整个身份认证体系等同于无效

与 SEC-6（堆栈泄露）叠加时，攻击者可同时获取系统内部信息和身份伪造能力，风险指数级放大。

#### 解决思路

1. **启动时强制校验**：应用启动时检查 SECRET_KEY 是否为默认值或空值，若是则拒绝启动并打印明确错误信息
2. **同步检查 REFRESH_SECRET_KEY**：刷新 Token 的密钥也需同等校验
3. **环境变量模板**：提供 `.env.example` 文件，标注必须配置的密钥字段
4. **不改变现有配置读取方式**：仍然通过 Pydantic Settings 从环境变量读取，仅增加校验逻辑
5. **若服务器未配置**：生成安全密钥命令 `python -c "import secrets; print(secrets.token_urlsafe(48))"`，将生成的值写入 `.env` 文件

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 添加启动校验函数 | `app/config.py` | 新增 `validate_critical_config()` 函数，检查 `SECRET_KEY`、`REFRESH_SECRET_KEY` 是否为默认值或长度不足 32 位 |
| 2 | 应用启动时调用校验 | `app/main.py` | 在 `app = FastAPI(...)` 之后、路由注册之前，调用 `validate_critical_config()`，校验失败则 `sys.exit(1)` |
| 3 | 定义不安全默认值黑名单 | `app/config.py` | `INSECURE_DEFAULTS = ["your-secret-key-change-in-production", "your-refresh-secret-key", "changeme", "secret", ""]` |
| 4 | 创建环境变量模板 | `backend/.env.example` | 列出所有必须配置的环境变量及说明 |
| 5 | 在服务器确认当前值 | 服务器操作 | 检查生产环境的 `.env` 或环境变量中 SECRET_KEY 是否已设置为安全值；若否，生成随机 64 字符密钥并配置 |

**校验函数伪代码**：

```python
def validate_critical_config(settings):
    INSECURE_DEFAULTS = [
        "your-secret-key-change-in-production",
        "your-refresh-secret-key",
        "changeme", "secret", ""
    ]
    errors = []
    if settings.SECRET_KEY in INSECURE_DEFAULTS or len(settings.SECRET_KEY) < 32:
        errors.append("SECRET_KEY 未设置安全值，请在环境变量中配置至少 32 位随机字符串")
    if settings.REFRESH_SECRET_KEY in INSECURE_DEFAULTS or len(settings.REFRESH_SECRET_KEY) < 32:
        errors.append("REFRESH_SECRET_KEY 未设置安全值")
    if errors:
        for e in errors:
            logger.critical(e)
        sys.exit(1)
```

**预估工作量**：0.5h

---

### 2.3 SEC-1：默认密码硬编码（v7.1 根据 07 确认更新）

#### 问题阐释

`team_management.py:428-437` 中，重置用户密码时使用硬编码的默认密码模式：`wj123456`、`jy123456`、`yz123456`、`m123456`、`123456`。任何能看到源码的人（包括 GitHub 仓库访问者）都能知道所有用户的默认密码。

#### 解决思路

07 确认密码重置方式为**经理指定**。修改重置密码接口为必须由经理输入新密码，移除所有硬编码默认密码。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 修改重置密码接口 | `app/api/team_management.py:428-437` | 增加**必填**参数 `new_password: str`，由经理指定新密码；添加密码强度校验（最少 6 位） |
| 2 | 删除硬编码密码模式 | 同上 | 删除 `wj123456`、`jy123456`、`yz123456`、`m123456`、`123456` 等所有硬编码字符串 |
| 3 | 前端适配 | `TeamManagement.jsx` | 重置密码弹窗增加"新密码"输入框（必填），经理输入后提交；移除原来的"一键重置"逻辑 |
| 4 | 修改初始化脚本 | `scripts/init_users.py` | 初始密码改为从环境变量 `DEFAULT_USER_PASSWORD` 读取 |

**预估工作量**：1h

---

### 2.4 DES-8：露出审核列表死锁 + 审核流程重设计（v7.1 根据 07 业务确认完全重写）

#### 问题阐释

`luchu_reviews.py:28-36` 的审核列表接口要求同时满足两个权限条件：
1. `get_luchu_authorized_user`（仅 wj01-wj10 通过）
2. `role in ['manager','leader']`

**死锁逻辑**：wj01-wj10 过了条件①但角色是 member 过不了条件②；manager/leader 角色满足条件②但不在 wj01-wj10 列表过不了条件①。**结果：没有任何用户能访问审核列表。**

#### 07 确认的实际业务需求（v7.1 新增）

07 明确了审核业务的真实规则，与 v7.0 基于 manager/leader 角色的假设**完全不同**：

| 阶段 | 时间范围 | 审核规则 | 发布规则 |
|------|---------|---------|---------|
| 阶段一（他审期） | 2026年3月-4月 | 文章必须由 **wj07 或 wj02** 审核通过后才能发布 | 审核通过后方可发布 |
| 阶段二（自审期） | 2026年5月起 | 作者自行审核（自审） | 自审通过后**立即发布** |

**关键约束**：
- 审核人**不是** manager/leader 角色，而是**具体用户** wj07 和 wj02
- 组长审核范围：仅限本组（wjzu 只能审核 wj 组的文章）
- 经理/组长不直接参与审核流程，不需要审核权限

#### 解决思路

v7.0 方案中基于 `UserRole.MANAGER / UserRole.LEADER` 角色的权限函数设计**不适用**，需要完全重新设计：

1. **新建审核人配置**：`LUCHU_REVIEWERS = ["wj07", "wj02"]`，独立于 `LUCHU_AUTHORIZED_USERS`（写文章权限）
2. **新建审核权限函数**：`get_luchu_reviewer()` 仅允许 `LUCHU_REVIEWERS` 中的用户通过
3. **分阶段发布策略**：添加配置开关 `LUCHU_SELF_REVIEW_ENABLED`，控制是否启用自审模式
4. **自审模式实现**：启用后，作者提交文章时自动标记为"已审核"，可直接进入发布流程

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 新增审核人配置 | `app/config.py` | `LUCHU_REVIEWERS: list = ["wj07", "wj02"]`，可通过环境变量覆盖 |
| 2 | 新增自审模式开关 | `app/config.py` | `LUCHU_SELF_REVIEW_ENABLED: bool = False`，3-4月设为 False（他审），5月起设为 True（自审） |
| 3 | 新建审核权限函数 | `app/middleware/auth.py` | `get_luchu_reviewer()`：仅 `LUCHU_REVIEWERS` 列表中的用户可通过 |
| 4 | 替换审核接口权限 | `app/api/luchu_reviews.py:31` | 将 `Depends(get_luchu_authorized_user)` 改为 `Depends(get_luchu_reviewer)` |
| 5 | 移除角色二次检查 | `app/api/luchu_reviews.py:35` | 删除 `role not in ['manager','leader']` 冗余检查 |
| 6 | 实现自审提交逻辑 | `app/api/luchu_articles.py` 提交接口 | 当 `SELF_REVIEW_ENABLED=True` 时，文章提交后自动标记 `status="approved"`，跳过审核环节 |
| 7 | 发布接口适配 | `app/api/luchu_publish.py` | 自审模式下，作者本人可直接发布自己已提交的文章 |
| 8 | 审核列表接口适配 | `app/api/luchu_reviews.py` | 自审模式下，审核列表仍可访问（wj07/wj02 仍可查看），但文章提交后自动通过 |
| 9 | 排查发布接口死锁 | `app/api/luchu_publish.py` | 检查发布权限是否也有类似双重拦截，若有则同步修复 |

**审核权限函数设计（v7.1 修正）**：

```python
LUCHU_REVIEWERS = settings.LUCHU_REVIEWERS  # ["wj07", "wj02"]

async def get_luchu_reviewer(current_user = Depends(get_current_user)):
    """审核权限：仅 LUCHU_REVIEWERS 中的指定用户可审核"""
    if current_user.username in LUCHU_REVIEWERS:
        return current_user
    raise HTTPException(403, "无审核权限，当前仅 wj07 和 wj02 可审核文章")
```

**自审模式提交逻辑伪代码**（v7.2 修正：status 值改为模型中已定义的 `"pending"` 和 `"approved"`）：

```python
async def submit_article(article_id, current_user, db):
    article = get_article(article_id, db)
    if settings.LUCHU_SELF_REVIEW_ENABLED:
        # 自审模式：提交即审核通过，可直接发布
        article.status = "approved"
        article.reviewed_by = current_user.username
        article.review_note = "自审通过"
        # 审计追溯：插入审核记录，标记为自审类型
        review_record = LuchuReview(
            article_id=article.id,
            reviewer=current_user.username,
            action="approved",
            review_type="self",   # "self"=自审, "peer"=他审
            note="自审通过"
        )
        db.add(review_record)
    else:
        # 他审模式：提交后等待 wj07/wj02 审核
        article.status = "pending"   # ← 使用模型中已定义的 "pending"，非 "pending_review"
    db.commit()
```

> **v7.2 修正说明**（应审核报告缺陷 1）：`LuchuArticle` 模型的 status 字段仅有 `draft/pending/approved/rejected/ready/published` 六种值（`luchu.py:59`），原伪代码中的 `"pending_review"` 不在其中，审核列表查询条件 `status == "pending"` 将无法匹配。已修正为 `"pending"`。

**发布接口权限修复方案**（v7.2 新增，应审核报告缺陷 2）：

审核报告已交叉验证 `luchu_publish.py:67-84`，确认发布接口存在与审核接口**同类的双重权限问题**：第一层 `Depends(get_luchu_authorized_user)` 限制 wj01-wj10，第二层 `role not in ['manager','leader']` 检查角色。

| 场景 | 发布人 | 当前能否发布 | 修复后 |
|------|--------|------------|--------|
| 阶段一：wj07 审核通过后，wj07 发布他人文章 | wj07（审核人） | ❌ 被第二层拦截（wj07 是 member） | ✅ 发布接口移除角色二次检查 |
| 阶段一：作者自己发布已审核通过的文章 | 作者本人 | ✅ 可以（`article.author_id == current_user.id` 绕过） | ✅ 保持 |
| 阶段二：作者自审后自己发布 | 作者本人 | ✅ 可以 | ✅ 保持 |

**发布接口修复步骤**：

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 9a | 移除发布接口角色二次检查 | `app/api/luchu_publish.py:67-84` | 删除 `role not in ['manager','leader']` 的冗余检查 |
| 9b | 添加发布权限逻辑 | 同上 | 允许以下用户发布：① 文章作者本人（`article.author_id == current_user.id`）且文章状态为 `approved`；② `LUCHU_REVIEWERS` 中的审核人（wj07/wj02）可发布任何已审核通过的文章 |
| 9c | 保留 `get_luchu_authorized_user` | 同上 | 第一层权限仍保留，确保仅露出功能授权用户可操作（但不再叠加角色检查） |

**存量 pending 文章迁移方案**（v7.2 新增，应审核报告疏漏 1）：

由于 DES-8 死锁，可能已有文章提交进入 `status="pending"` 却无人能审核。修复上线后需处理这些存量文章：

| 步骤 | 操作 | 详情 |
|------|------|------|
| 10 | 修复上线后执行数据检查 | `SELECT id, title, author_id, status, created_at FROM luchu_articles WHERE status = 'pending'` |
| 11 | 处理存量 pending 文章 | 若有，通知 wj07/wj02 在新权限系统下审核这些文章；若文章已过时，可由审核人批量标记为 `rejected` 并通知作者重新提交 |

**自审模式审计追溯设计**（v7.2 新增，应审核报告疏漏 5）：

为区分"自审通过"和"他人审核通过"，在 `LuchuReview` 表中新增 `review_type` 字段：

| 字段 | 类型 | 值 | 说明 |
|------|------|----| -----|
| `review_type` | VARCHAR(10) | `"peer"` | 他审（wj07/wj02 审核，阶段一默认值） |
| `review_type` | VARCHAR(10) | `"self"` | 自审（作者自审，阶段二默认值） |

审核记录查询示例：`SELECT * FROM luchu_reviews WHERE review_type = 'self'` 可追溯所有自审通过的文章。

**蝴蝶效应预判**（v7.2 更新）：

```
阶段一（3-4月他审期）：
    wj01-wj10 写文章 → 提交 → status="pending"
        ↓
    wj07 或 wj02 登录 → 审核列表可见 → 审核通过/拒绝
        ↓ 通过
    文章 status="approved"，LuchuReview 记录 review_type="peer"
        ↓ 发布
    作者本人 或 wj07/wj02 均可发布已审核通过的文章
        ↓ wj07 发布他人文章时
    → 通过 LUCHU_REVIEWERS 身份检查 ✓（不再被角色检查拦截）

阶段二（5月起自审期）：
    修改 LUCHU_SELF_REVIEW_ENABLED=True（修改环境变量，无需改代码）
        ↓
    wj01-wj10 写文章 → 提交 → 自动 status="approved"
    → LuchuReview 记录 review_type="self"（审计追溯）
        ↓
    作者直接发布
        ↓ 审核列表
    wj07/wj02 仍可查看审核列表（只是不再有待审核文章）
    → 如需恢复他审，只需改回 LUCHU_SELF_REVIEW_ENABLED=False

⚠️ 安全兜底：
    → wj07/wj02 在自审期仍可将已发布文章标记为"rejected"并下架
    → 所有审核操作（包括自审）均有 LuchuReview 记录可追溯
```

**预估工作量**：3h（v7.2 增加：发布接口修复 +0.5h，审计追溯字段 +0.5h，存量迁移 +0.5h，原 2.5h 中扣除不再需要的"排查"时间 -0.5h）

---

### 2.5 DES-2/CODE-5：platform-summary 500 数据类型错误

#### 问题阐释

`dashboard.py:648-654` 中，`row.get("点击", 0)` 等取值可能返回字符串类型（如 `"1,234"` 或 `"$50"`），直接与 int 做 `+=` 运算导致 `TypeError: unsupported operand type(s) for +: 'int' and 'str'`。这是第二轮测试确认的真实 500 错误。

#### 解决思路

1. **编写安全数字转换函数**：处理字符串中的逗号、美元符号、百分号等非数字字符
2. **在所有数值运算处使用安全转换**：不只修复 `row.get("点击", 0)`，而是覆盖该函数中所有数值字段
3. **添加类型异常兜底**：即使安全转换失败，也返回默认值 0 而非抛出异常

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 新增安全数值转换工具函数 | `app/utils/` 或 `dashboard.py` 顶部 | `safe_number(value, default=0)` 函数：去除逗号/美元符等，尝试转为 float，失败返回 default |
| 2 | 替换所有裸取值操作 | `dashboard.py:648-654` | `row.get("点击", 0)` → `safe_number(row.get("点击", 0))` |
| 3 | 覆盖全部数值字段 | `dashboard.py` 中所有做算术运算的取值 | 全文搜索 `row.get(` 和 `+= `，确保所有数值操作都经过安全转换 |

**安全转换函数**（v7.2 增强，应审核报告疏漏 4：覆盖 N/A、null、空字符串、会计格式负数等常见边界值）：

```python
def safe_number(value, default=0):
    if isinstance(value, (int, float)):
        return value
    if value is None:
        return default
    if isinstance(value, str):
        stripped = value.strip()
        # 显式空值/null值识别
        if stripped in ("", "N/A", "n/a", "null", "None", "-", "--", "—"):
            return default
        # 会计格式负数处理：(1,234) → -1234
        is_negative = stripped.startswith("(") and stripped.endswith(")")
        if is_negative:
            stripped = stripped[1:-1]
        cleaned = stripped.replace(",", "").replace("$", "").replace("%", "").strip()
        try:
            result = float(cleaned) if "." in cleaned else int(cleaned)
            return -result if is_negative else result
        except (ValueError, TypeError):
            return default
    return default
```

**预估工作量**：0.5h

---

## 三、P1 级修复方案（上线前必须处理）

### 3.1 SEC-7：Access Token 存储在 localStorage（审核新发现）

#### 问题阐释

`frontend/src/store/authStore.js:6,22` 中，Access Token 通过 `localStorage.setItem('token', access_token)` 存储。localStorage 可被任何运行在同源页面上的 JavaScript 代码读取，包括：

- 第三方库中的 XSS 漏洞（如 Ant Design 5 组件）
- 露出功能中 AI 生成文章内容若未充分消毒
- 浏览器扩展程序

一旦 Token 被窃取，攻击者可在 Token 有效期内完全冒充该用户。

**注意**：审核报告第 46 项验证确认 Refresh Token 已正确使用 httpOnly Cookie ✅，仅 Access Token 存在此问题。

#### 解决思路

有两种方案：

| 方案 | 优点 | 缺点 | 适合场景 |
|------|------|------|---------|
| A. Access Token 纯内存存储 + Refresh Token httpOnly Cookie 无感刷新 | 最安全，XSS 无法窃取 Token | 页面刷新后需重新获取 Token（通过 Refresh Token）；实现复杂度高 | 高安全要求 |
| B. Access Token 缩短有效期至 15 分钟 + 保持 localStorage | 改动最小 | 仍有 15 分钟窗口期被窃取；治标不治本 | 快速修复 |

**推荐方案 A**：既然 Refresh Token 已使用 httpOnly Cookie，Access Token 改为内存存储的额外成本可控。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 移除 localStorage 存储 | `frontend/src/store/authStore.js` | 删除 `localStorage.setItem('token', ...)` 和 `localStorage.getItem('token')`，Token 仅存在 Zustand store 内存中 |
| 2 | 添加启动时自动刷新 | `frontend/src/store/authStore.js` | 应用启动时（`useEffect`）调用 `POST /api/auth/refresh`（带 httpOnly Cookie），获取新 Access Token 存入内存 |
| 3 | 添加 401 自动重试 | `frontend/src/utils/api.js` 或 axios 拦截器 | 收到 401 时自动调用 refresh 接口，成功后重试原请求；refresh 也失败则跳转登录页 |
| 4 | 后端确认 refresh 接口 | `backend/app/api/auth.py` | 确认 `POST /api/auth/refresh` 从 httpOnly Cookie 读取 Refresh Token 并返回新 Access Token |
| 5 | 缩短 Access Token 有效期 | `backend/app/config.py` | Access Token 有效期从当前值缩短至 15 分钟（即使被窃取，窗口期也很短） |

**跨标签页 refresh 协调方案**（v7.2 新增，应审核报告疏漏 3）：

多标签页场景下，每个标签页独立维护内存中的 Token，页面加载时各自调用 `POST /api/auth/refresh`。若用户同时打开 5 个标签页，将产生 5 次几乎同时的 refresh 请求，可能触发 SEC-10 的速率限制（每分钟 10 次）。

审核已验证 `api.js:195-207` 中存在 `isRefreshing` 并发控制机制，但仅在单标签页内有效，不跨标签页。

| 解决方案 | 实现 | 详情 |
|---------|------|------|
| 方案 A：BroadcastChannel 协调 | `frontend/src/utils/tokenSync.js` | 使用 `BroadcastChannel API` 在标签页间广播新 Token，只有第一个触发 refresh 的标签页实际调用接口，其他标签页监听并复用结果 |
| 方案 B：放宽速率限制 | `backend/app/api/auth.py` | 将 SEC-10 的 refresh 速率限制从每分钟 10 次放宽到每分钟 30 次，容纳多标签页场景 |
| **推荐** | **A+B 结合** | 前端用 BroadcastChannel 减少请求量，后端适当放宽限制作为兜底 |

**蝴蝶效应预判**（v7.2 更新）：

```
移除 localStorage Token 存储
    ↓ 页面刷新后 Token 丢失
    → 通过 Refresh Token Cookie 重新获取
    ↓ 若 Refresh Token 也过期
    → 用户被跳转到登录页（正常行为）
    ↓ 若有多个标签页同时打开
    → BroadcastChannel 协调，仅一个标签页调用 refresh
    → 其他标签页监听并复用 Token（v7.2 新增）
    ↓ 若浏览器不支持 BroadcastChannel（IE 等）
    → 降级为各自 refresh（SEC-10 放宽至 30 次/分钟兜底）
```

**预估工作量**：4h（v7.2 增加：BroadcastChannel 协调 +1h）

---

### 3.2 SEC-6：生产环境泄露完整堆栈（审核新发现）

#### 问题阐释

`backend/app/main.py:228-229` 中全局异常处理器使用 `traceback.print_exc()`，在生产环境中将完整堆栈信息输出到标准输出/日志。虽然不会直接在 HTTP 响应中返回堆栈，但结合 DES-2 等 500 错误场景，FastAPI 默认的 500 响应可能包含详细错误信息，暴露内部文件路径、数据库结构、依赖版本等。

#### 解决思路

1. **区分开发与生产环境**：通过环境变量 `ENV` 或 `DEBUG` 控制错误输出详细程度
2. **生产环境**：HTTP 响应仅返回通用错误消息 `{"detail": "Internal server error"}`，详细堆栈写入日志文件
3. **开发环境**：保持当前行为，方便调试

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 添加环境模式配置 | `app/config.py` | 新增 `DEBUG: bool = False`，生产环境设为 `False` |
| 2 | 修改全局异常处理器 | `app/main.py:228-229` | `if settings.DEBUG: traceback.print_exc()` + `else: logger.exception("Unhandled error")`；响应统一返回 `{"detail": "Internal server error"}` |
| 3 | 审查其他异常处理点 | `app/main.py` 全文 | 搜索 `traceback`、`exc_info`、`print_exc` 等，确保所有异常处理都遵循同一规则 |
| 4 | 确认生产环境配置 | 服务器 `.env` | 确认 `DEBUG=false` 已配置 |

**预估工作量**：0.5h

---

### 3.3 SEC-2/SEC-3：敏感 Token 泄露（v7.1 根据 07 确认更新：Token 不可轮换）

#### 问题阐释

审核报告发现实际含敏感 Token 的文件数量比 v6.4 设计方案列出的更多：

| Token 类型 | v6.4 列出文件数 | 审核实际发现文件数 | 遗漏 |
|-----------|---------------|-----------------|------|
| Developer Token `hWBTxgYlOiWB4XfXQl_UfA` | 4 个 | **7 个** | 2 个文档文件 + 1 个脚本 |
| CollabGlow Token `916a0dbb...` | 1 个 | **2 个** | 1 个文件 |
| Rewardoo Token `41df7906...` | 1 个 | **4 个** | 3 个文档文件 |

#### 07 确认的约束（v7.1）

**Developer Token 不可轮换**，仍使用原 Token。这意味着 v7.0 中"轮换 Token 使历史失效"的方案**不可行**，需要用其他方式处理 Git 历史中的泄露问题。

#### 解决思路

既然不能轮换 Token，需要双管齐下：
1. **源码层面**：从所有文件中删除 Token 明文，改为从环境变量读取
2. **Git 历史层面**：评估是否需要用 BFG Repo Cleaner 清理 Git 历史；若仓库为 **private**（目前 GitHub 仓库为 private），Git 历史中的 Token 风险可控；若为 **public** 则必须清理
3. **预防层面**：添加 `.gitignore` 和 pre-commit hook 防止未来再次泄露

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 全局搜索 Developer Token | 整个仓库 | 搜索 `hWBTxgYlOiWB` 前缀，列出所有 7 个匹配文件 |
| 2 | 全局搜索 CollabGlow Token | 整个仓库 | 搜索 `916a0dbb` 前缀 |
| 3 | 全局搜索 Rewardoo Token | 整个仓库 | 搜索 `41df7906` 前缀 |
| 4 | 删除含 Token 的脚本文件 | 各脚本 | 一次性脚本直接删除（这些脚本本身就在赘余文件清理清单中） |
| 5 | 清理文档中的 Token | 各文档 | Token 值替换为 `<从环境变量读取>` 占位符 |
| 6 | 确认仓库可见性 | GitHub | 确认 `starrats111/Google-Data-Analysis` 是否为 **private** 仓库 |
| 7a | 若仓库为 private | 无需额外操作 | Git 历史中的 Token 仅有仓库成员可见，风险可控 |
| 7b | 若仓库为 public | 使用 BFG 清理 | `bfg --replace-text tokens.txt repo.git`，从 Git 历史中彻底删除 Token 字符串 |
| 8 | 添加 `.gitignore` 规则 | `.gitignore` | 确保 `.env` 文件不会被提交 |
| 9 | Token 统一环境变量化 | `app/config.py` + 服务器 `.env` | 所有 Token 仅通过环境变量读取，源码中零明文 |

**预估工作量**：1.5h（不含 BFG 清理；若需 BFG 则额外 1h）

---

### 3.4 ARCH-2：定时任务无并发控制（审核新发现）

#### 问题阐释

`backend/app/services/scheduler.py` 使用 APScheduler 的 `BackgroundScheduler`，但未设置任务执行状态锁。当前定时任务安排：

- CRON-1：04:00 每日同步（Google Ads + 平台数据 + 分析）
- CRON-2：05:00 数据补齐（v6.4 新增）

若 CRON-1 在 04:00 开始执行，因网络慢/API 超时导致执行超过 1 小时未完成，CRON-2 在 05:00 会并发启动。两个任务共享 Google Ads API 配额（Explorer 级约 15,000 次/日），并发执行将：

1. 配额双倍消耗，几乎必然耗尽
2. 可能导致重复数据写入
3. 两个任务可能互相干扰对方的数据库事务

#### 解决思路

1. **最简单方案**：使用 APScheduler 自带的 `max_instances=1` 参数，限制同一任务同时只能有一个实例运行
2. **任务间依赖**：CRON-2 应在 CRON-1 完成后才启动，可用文件锁或数据库锁实现
3. **超时保护**：任务执行超过最大时长时自动终止并告警

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 设置 max_instances | `app/services/scheduler.py` | 所有 `add_job()` 调用添加 `max_instances=1`，防止同一任务并发 |
| 2 | 添加任务执行锁 | `app/services/scheduler.py` | 使用 `threading.Lock` 或文件锁，确保 CRON-1 和 CRON-2 互斥执行 |
| 3 | CRON-2 检查 CRON-1 状态 | `app/services/scheduler.py` | CRON-2 启动时检查 CRON-1 是否仍在运行，若是则跳过本次执行并记录日志 |
| 4 | 添加超时保护 | `app/services/scheduler.py` | 任务执行超过 2 小时自动终止，记录 warning 日志 |
| 5 | 执行状态记录 | `app/services/scheduler.py` | 维护一个内存字典记录每个任务的开始时间和状态，供健康检查接口查询 |

**互斥锁实现伪代码**：

```python
import threading

_sync_lock = threading.Lock()

def daily_auto_sync_and_analysis_job():
    if not _sync_lock.acquire(blocking=False):
        logger.warning("CRON-1 跳过：另一个同步任务正在执行")
        return
    try:
        # 原有同步逻辑
        ...
    finally:
        _sync_lock.release()

def backfill_missing_data_job():
    if not _sync_lock.acquire(blocking=False):
        logger.warning("CRON-2 跳过：另一个同步任务正在执行")
        return
    try:
        # 原有补齐逻辑
        ...
    finally:
        _sync_lock.release()
```

> **⚠️ 单进程部署约束**（v7.2 新增，应审核报告疏漏 2）：审核已确认当前 uvicorn 启动命令为 `uvicorn app.main:app --host 0.0.0.0 --port 8000`（无 `--workers` 参数），即单进程模式，因此 `threading.Lock` 方案有效。**若未来为性能改为多 worker 模式（`--workers 4`），`threading.Lock` 将失效**（每个 worker 有独立锁），需改用文件锁（`fcntl.flock`）或数据库锁（advisory lock）。建议在部署文档中注明此约束。

**预估工作量**：1h

---

### 3.5 SEC-8：无数据库备份机制（审核新发现）

#### 问题阐释

系统使用 SQLite 数据库（生产环境），目前没有任何自动备份机制。风险场景：

1. 数据库文件损坏（磁盘故障、突然断电）
2. 误操作删除数据
3. 攻击者恶意修改数据
4. v7.0 整改过程中需要删除 80+ 个文件，误删数据库则无法回滚

审核报告特别指出：**在执行任何清理操作前，必须先建立备份机制。**

#### 解决思路

1. **自动每日备份**：利用现有定时任务框架，添加每日数据库备份任务
2. **SQLite 备份方式**：使用 Python `sqlite3` 的 `backup()` API 进行在线备份（不需停服）
3. **备份保留策略**：保留最近 7 天的每日备份 + 最近 4 周的每周备份
4. **备份文件存储**：存储在服务器的独立目录，与数据库文件不在同一磁盘分区（如可能）

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 创建备份服务 | `app/services/backup_service.py` | 实现 `backup_database()` 函数：使用 `sqlite3.backup()` API 复制数据库到备份目录，文件名含时间戳 |
| 2 | 注册定时任务 | `app/services/scheduler.py` | 每天 03:00（在 CRON-1 之前）执行备份，确保同步前数据已备份 |
| 3 | 实现备份清理 | `app/services/backup_service.py` | 保留最近 7 天每日备份 + 每周日备份保留 4 周，自动删除过期备份 |
| 4 | 配置备份目录 | `app/config.py` | 新增 `BACKUP_DIR: str = "/data/backups"` 配置项 |
| 5 | 手动备份接口（可选） | `app/api/system.py` | 经理可通过 API 触发手动备份 |
| 6 | 立即执行一次备份 | 服务器操作 | 在开始任何清理工作前，手动执行一次完整备份 |

**预估工作量**：1.5h

---

## 四、P2 级修复方案（近期处理）

### 4.1 SEC-12：启动时无关键配置校验（审核新发现）

#### 问题阐释

`backend/app/config.py` 中 `SECRET_KEY`、`DATABASE_URL`、`REFRESH_SECRET_KEY` 等关键配置若缺失或使用默认值，系统仍能正常启动但处于不安全状态。SEC-5 仅解决了 SECRET_KEY 的校验，SEC-12 要求对所有关键配置进行统一校验。

#### 解决思路

将 SEC-5 的校验函数扩展为通用配置校验，覆盖所有关键配置项。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 扩展校验函数 | `app/config.py` | `validate_critical_config()` 增加对 `DATABASE_URL`（非 SQLite 默认路径）、`GOOGLE_ADS_DEVELOPER_TOKEN`（非空）、`GEMINI_API_KEY`（非空）等的校验 |
| 2 | 分级校验 | 同上 | 关键项（SECRET_KEY）缺失则拒绝启动；次要项（GEMINI_API_KEY）缺失则打印 warning 但允许启动 |
| 3 | 启动日志 | `app/main.py` | 启动时打印配置校验摘要：`✅ SECRET_KEY: 已配置` / `⚠️ GEMINI_API_KEY: 未配置，AI 功能将不可用` |

**预估工作量**：0.5h（与 SEC-5 合并实施）

---

### 4.2 DES-6：露出功能权限设计不合理（v7.1 根据 07 确认更新）

#### 问题阐释

`middleware/auth.py:175` 中 `LUCHU_AUTHORIZED_USERS` 仅包含 `wj01`-`wj10`，硬编码在源码中。当前问题：

1. 经理 `manager` 和组长 `wjzu/jyzu/yzzu` 不在列表中（但根据 DES-8 v7.1，审核由 wj07/wj02 负责，经理/组长不需要审核权限，此点不再是问题）
2. **未来 jy 组、yz 组可能也需要使用露出功能**（07 确认：视情况，可能需要）
3. 硬编码列表无法灵活调整，每次变更都需要改代码重新部署

#### 解决思路

将硬编码列表改为配置化，支持通过环境变量或配置文件动态调整，无需改代码即可扩展到其他组。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 写文章权限移至配置 | `app/config.py` | `LUCHU_AUTHORIZED_USERS: str = "wj01,wj02,...,wj10"`，环境变量格式为逗号分隔字符串，代码中 split 为列表 |
| 2 | 审核人配置 | `app/config.py` | `LUCHU_REVIEWERS: str = "wj07,wj02"`（与 DES-8 联动） |
| 3 | auth.py 改为读配置 | `app/middleware/auth.py:175` | `LUCHU_AUTHORIZED_USERS = settings.LUCHU_AUTHORIZED_USERS.split(",")` |
| 4 | 未来扩展方式 | 环境变量修改 | 若 jy 组需要使用，只需在环境变量中追加 `jy01,jy02,...,jy10`，重启服务即可生效，无需改代码 |

**预估工作量**：0.5h

---

### 4.3 DES-7：Google OAuth 模块已弃用

#### 问题阐释

07 已确认 Google Ads 数据获取改用服务账号模式，不再使用 OAuth 流程。但 `app/api/google_oauth.py` 仍注册路由，前端 `GoogleOAuthCallback.jsx` 仍存在且有路由注册。

#### 解决思路

彻底删除 OAuth 模块，但需注意审核报告提到的蝴蝶效应：

```
删除 google_oauth.py → 需同步删除 main.py 路由注册
    → 需删除前端 GoogleOAuthCallback.jsx 及其路由
    → 需确认无其他代码 import 该模块
    → 需确认服务器上无正在使用的 OAuth Token
```

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 全局搜索引用 | 整个仓库 | 搜索 `google_oauth`、`GoogleOAuth`、`google-oauth` 确认所有引用位置 |
| 2 | 删除后端模块 | `app/api/google_oauth.py` | 删除整个文件 |
| 3 | 移除路由注册 | `app/main.py` | 删除 `google_oauth` 路由的 `include_router` |
| 4 | 删除前端页面 | `frontend/src/pages/GoogleOAuthCallback.jsx` | 删除文件 |
| 5 | 移除前端路由 | `frontend/src/App.jsx` | 删除 `/google-oauth-callback` 路由配置 |
| 6 | 确认服务器状态 | 服务器操作 | 确认服务器已完全切换到服务账号模式，无正在使用的 OAuth Token |

**预估工作量**：0.5h

---

### 4.4 ARCH-1：无数据库迁移管理系统（审核新发现）

#### 问题阐释

系统未使用 Alembic 或任何数据库迁移框架。当前 20+ 个 SQLAlchemy 模型的 Schema 变更全靠手动创建一次性脚本（如 `add_*_column.py`），存在以下问题：

- Schema 变更无法追踪、回滚、复现
- 多环境（开发/生产）部署可能 Schema 不一致
- `scripts/` 中有 15+ 个数据库迁移脚本，执行状态无法确认

#### 解决思路

引入 Alembic 作为数据库迁移管理工具，但考虑到当前系统已在生产运行，需要渐进式引入。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 安装 Alembic | `requirements.txt` | 添加 `alembic` 依赖 |
| 2 | 初始化 Alembic | `backend/` | `alembic init alembic`，生成配置文件 |
| 3 | 配置数据库连接 | `alembic/env.py` | 从 `app/config.py` 读取 `DATABASE_URL` |
| 4 | 生成初始迁移 | `alembic/versions/` | 以当前 Schema 为基线生成初始迁移文件：`alembic revision --autogenerate -m "initial schema"` |
| 5 | 标记已执行 | 服务器操作 | 在生产服务器执行 `alembic stamp head`，标记当前状态为已迁移 |
| 6 | 后续变更流程 | 文档 | 任何模型变更都必须通过 `alembic revision --autogenerate` 生成迁移文件 |

**注意**：此项不紧急，可在本轮 P0/P1 修复完成后再引入。引入过程不影响现有系统运行。

**预估工作量**：2h

---

### 4.5 ARCH-3：历史数据同步无日期范围上限（审核新发现）

#### 问题阐释

`backend/app/api/mcc.py:829-861` 的历史数据同步接口允许用户请求任意大的日期范围。若用户（或恶意请求）指定 5 年的日期范围，将导致：

- API 配额瞬间耗尽（Explorer 级别每日仅约 15,000 次调用）
- 大量数据加载导致内存溢出
- 后台任务队列被长时间阻塞

#### 解决思路

添加最大范围限制 + 参数校验。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 添加日期范围校验 | `app/api/mcc.py:829-861` | 计算 `end_date - start_date`，超过 90 天返回 400 错误 |
| 2 | 添加配置项 | `app/config.py` | `MAX_SYNC_DATE_RANGE_DAYS: int = 90` |
| 3 | 前端限制 | `MccAccounts.jsx` | 日期选择器最大范围限制为 90 天，并显示提示信息 |

**预估工作量**：0.5h

---

### 4.6 SEC-9：数据同步接口缺少速率限制（审核新发现）

#### 问题阐释

`/api/mcc/accounts/{id}/sync`、`/api/platform-data/sync-realtime` 等同步接口无速率限制。频繁触发同步将耗尽 Google Ads API 配额（Explorer 级配额极低），进而导致 CRON-1、CRON-2 定时任务失败。

#### 解决思路

使用轻量级内存速率限制器（不引入 Redis 等额外依赖）。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 创建速率限制工具 | `app/utils/rate_limiter.py` | 基于内存字典的滑动窗口速率限制器 |
| 2 | 应用到同步接口 | `app/api/mcc.py` | 每个 MCC 账号每小时最多 2 次手动同步 |
| 3 | 应用到平台同步 | `app/api/platform_data.py` | 每个用户每小时最多 5 次手动同步 |
| 4 | 超限返回友好提示 | 各接口 | 返回 429 Too Many Requests + 下次可用时间 |

**预估工作量**：1h

---

### 4.7 DES-1：CORS 四重冗余（审核修正为四层）

#### 问题阐释

审核报告修正：CORS 处理实际是**四层**而非设计方案中描述的三层：

1. `CORSMiddleware`（main.py:105-114）：标准 Starlette CORS 中间件
2. `cors_logging_middleware`（main.py:176-207）：自定义日志中间件，也设置 CORS 头
3. `options_handler`（main.py:282-294）：手动 OPTIONS 预检处理
4. `get_cors_headers` 辅助函数（main.py:141-171）：额外的 CORS 头生成

审核报告还指出蝴蝶效应：精简后 500 错误的响应可能不经过 CORSMiddleware，导致前端收到 CORS 错误而非 500 错误。

#### 解决思路

精简为仅 CORSMiddleware，但需确保异常响应也包含 CORS 头。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 保留 CORSMiddleware | `app/main.py` | 保持标准 Starlette CORSMiddleware 配置 |
| 2 | 删除 cors_logging_middleware | `app/main.py:176-207` | 删除自定义日志中间件 |
| 3 | 删除 options_handler | `app/main.py:282-294` | 删除手动 OPTIONS 处理 |
| 4 | 删除 get_cors_headers | `app/main.py:141-171` | 删除辅助函数 |
| 5 | 异常处理加 CORS 头 | `app/main.py` 全局异常处理器 | 在 500 错误响应中手动添加 `Access-Control-Allow-Origin` 头，确保前端能正确区分 CORS 错误和服务器错误 |
| 6 | 部署后验证 | 服务器操作 | 部署后使用 `curl -I` 验证正常请求和错误请求都返回正确的 CORS 头 |

**蝴蝶效应应对**：在全局异常处理器中显式添加 CORS 头，确保即使 500 错误，前端也能收到正确的 CORS 头和错误信息。

**预估工作量**：1.5h

---

### 4.8 DES-3：废弃端点未清理

#### 问题阐释

`POST /api/analysis/process` 返回 410 Gone 但仍注册在路由中，增加代码噪音。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 删除废弃路由 | `app/api/analysis.py` | 删除返回 410 的路由函数 |
| 2 | 确认无引用 | 全局搜索 | 搜索 `analysis/process` 确认前端无调用 |

**预估工作量**：0.1h

---

### 4.9 CODE-1/CODE-2：重复代码清理

#### 问题阐释

- CODE-1：`scripts/sync_all_mcc_07.py` 第 1-104 行和第 106-208 行完全重复
- CODE-2：`config.py:86-104` 两个域名在列表中各出现两次

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 删除重复代码 | `scripts/sync_all_mcc_07.py` | 删除第 106-208 行重复部分 |
| 2 | 删除重复域名 | `app/config.py:86-104` | 删除重复的域名条目 |

**预估工作量**：0.2h

---

### 4.10 赘余文件清理（含蝴蝶效应应对）

#### 问题阐释

80+ 个赘余文件需清理，审核报告指出以下蝴蝶效应：

1. 部分脚本可能被定时任务或其他脚本引用（import 或 subprocess）
2. Git 历史中的敏感信息仍然存在
3. 需在删除前全文搜索每个文件名

#### 最终方案

| 步骤 | 操作 | 详情 |
|------|------|------|
| 1 | **先备份数据库** | 执行 SEC-8 的备份方案后再开始清理 |
| 2 | **依赖检查** | 对每个待删除文件，全局搜索其文件名确认无引用 |
| 3 | **分批删除** | 先删根目录 20 个 → 测试 → 再删 scripts/ 下 60+ 个 → 测试 → 最后删前端 3 个废弃页面 |
| 4 | **每批后验证** | 删除后运行 `full_system_test.py` 确认系统正常 |
| 5 | **Git 清理** | 清理完成后，通过 Token 轮换（SEC-2/SEC-3）使 Git 历史中的 Token 失效 |

详细清理清单见 v6.4 原方案第五节（此处不再重复）。

**预估工作量**：2h

---

## 五、P3 级修复方案（后续迭代）

### 5.1 SEC-10：Token 刷新接口无速率限制

#### 问题阐释

`POST /api/auth/refresh` 无速率限制，可被用于 Token 轰炸攻击。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 添加速率限制 | `app/api/auth.py` | 每用户每分钟最多 10 次 refresh 请求 |
| 2 | 复用速率限制器 | `app/utils/rate_limiter.py` | 使用 SEC-9 中创建的速率限制工具 |

**预估工作量**：0.3h

---

### 5.2 SEC-11：文件上传文件名未清理

#### 问题阐释

`backend/app/api/upload.py:79` 虽然有白名单和大小限制，但文件名含特殊字符（如 `../../etc/passwd`）可能导致路径遍历。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 文件名清理 | `app/api/upload.py:79` | 使用 `uuid4()` + 原始扩展名重命名上传文件，如 `a1b2c3d4.xlsx` |
| 2 | 保留原始文件名 | 同上 | 原始文件名存入数据库记录中，供下载时使用 |

**预估工作量**：0.3h

---

### 5.3 ARCH-4：API 配额耗尽无自动恢复

#### 问题阐释

`backend/app/services/google_ads_service_account_sync.py` 检测到配额错误后直接停止，无指数退避重试。配额短暂耗尽后需等到下一个定时任务周期才能恢复。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 实现指数退避 | `app/services/google_ads_service_account_sync.py` | 配额错误后：等待 1 分钟重试 → 5 分钟 → 15 分钟 → 1 小时 → 放弃并记录错误 |
| 2 | 配额状态缓存 | 同上 | 记录上次配额错误时间，短期内不再发起新请求 |

**预估工作量**：1h

---

### 5.4 ARCH-5：大量查询使用 .all() 无分页

#### 问题阐释

`scheduler.py`、`api_analysis_service.py` 等多处使用 `.all()` 一次性加载全部记录。当前数据量小时无感，3-6 个月后随着 Google Ads 数据每日累积（预估月增 10 万行），问题会逐渐显现。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 识别高危查询 | 全局搜索 `.all()` | 找出所有不带 LIMIT 的查询，按数据表增长速度排序 |
| 2 | 添加分页 | 各 API 接口 | 对用户可见的列表接口添加 `page` + `page_size` 参数 |
| 3 | 内部查询批处理 | 定时任务等内部逻辑 | 使用 `.yield_per(1000)` 或手动分批处理 |

**预估工作量**：3h（涉及多个文件）

---

### 5.5 ARCH-6：多步数据库操作缺乏事务保护

#### 问题阐释

`backend/app/api/mcc.py` 等多个 API handler 中，多步写入操作（如创建 MCC 账号 + 设置关联数据）失败中途时，部分数据已提交无法回滚。

#### 最终方案

| 步骤 | 操作 | 文件 | 详情 |
|------|------|------|------|
| 1 | 识别多步写入操作 | 全局搜索 `db.commit()` | 找出同一函数中多次 commit 的位置 |
| 2 | 合并事务 | 各 API handler | 将多次 commit 合并为一次，使用 `try/except` + `db.rollback()` 包裹 |
| 3 | 关键操作加事务装饰器 | `app/utils/` | 创建 `@transactional` 装饰器，自动处理提交和回滚 |

**预估工作量**：2h

---

### 5.6 DES-4：OpenAI 配置残留

#### 问题阐释

`config.py:133-134,158` 中 `OPENAI_API_KEY`、`OPENAI_MODEL`、`OPENAI_BASE_URL` 仍在配置中，但系统只使用 Gemini/Claude。

#### 最终方案

删除 `config.py` 中所有 OpenAI 相关配置项。

**预估工作量**：0.1h

---

## 六、蝴蝶效应全景分析

### 6.1 修复操作连锁影响预判（v7.0 补充）

| 修复项 | 直接影响 | 间接影响 | 风险缓解措施 |
|--------|---------|---------|-------------|
| SEC-4 修复 wenjun123 | 权限检查逻辑变更 | UserRole 枚举值大小写、数据库中用户记录一致性 | 先确认枚举值再改代码；先查数据库再删脚本 |
| SEC-5 启动校验 | 不安全配置时拒绝启动 | 若服务器未配置环境变量，部署后服务无法启动 | 先在服务器配置好环境变量再部署 |
| DES-8 wj07/wj02 专人审核 + 分阶段发布 | 审核接口仅 wj07+wj02 可访问；自审模式下提交即通过 | 自审模式切换时机（环境变量修改）；自审期间是否需要保留驳回能力 | 环境变量控制开关，无需改代码；保留审核人驳回/下架能力 |
| SEC-7 Token 内存化 | 页面刷新后需重新获取 Token | 多标签页场景、弱网环境下 refresh 失败处理 | 401 自动重试 + 优雅降级到登录页 |
| ARCH-2 并发控制 | 定时任务互斥执行 | 若 CRON-1 持续超时，CRON-2 永远无法执行 | 超时保护（2h 自动终止）+ 独立补偿机制 |
| CORS 精简 | 删除冗余层 | 500 错误时 CORS 头可能丢失 | 全局异常处理器中显式添加 CORS 头 |
| 赘余文件清理 | 删除 80+ 文件 | 误删被引用文件导致运行时错误 | 每个文件删前全局搜索引用 + 分批删除 + 每批后测试 |
| SEC-2/SEC-3 Token 清理 | 文件中 Token 被删除 | Git 历史中仍可恢复；Developer Token 不可轮换 | 确认仓库为 private（历史风险可控）；若为 public 则用 BFG 清理 |

### 6.2 修复顺序依赖图

```
SEC-8 数据库备份（最先执行，保障安全网）
    ↓
SEC-5a 服务器密钥替换 ✅ 已完成
SEC-5b + SEC-12 启动配置校验代码（修改 config.py 和 main.py）
    ↓
SEC-4 硬编码修复（UserRole 枚举值已确认 ✅，可直接实施）
    ↓
DES-8 + DES-6 露出权限修复（依赖 auth.py 改动）
    ↓
DES-2/CODE-5 数据类型修复（独立，可并行）
SEC-6 堆栈泄露修复（独立，可并行）
    ↓
SEC-1 密码硬编码（独立，可并行）
ARCH-2 并发控制（独立，可并行；⚠️ 限单进程部署）
    ↓
SEC-7 Token 内存化 + BroadcastChannel 协调（前后端联动）
    ↓
SEC-2/SEC-3 Token 清理（在功能修复完成后统一清理）
    ↓
DES-1 CORS 精简（影响面广，在其他修复验证通过后再做）
DES-7 OAuth 清理（影响面窄，可并行）
    ↓
赘余文件清理（最后执行，确保无误删）
    ↓
ARCH-1 引入 Alembic（稳定后再引入）
```

---

## 七、前瞻性风险评估（v7.0 补充）

### 7.1 数据量增长风险

| 时间节点 | 预估数据量 | 可能出现的问题 | 对应方案 |
|---------|-----------|--------------|---------|
| 1 个月后 | Google Ads 数据约 10 万行 | `.all()` 查询开始变慢，dashboard 响应超过 5 秒 | ARCH-5 分页 |
| 3 个月后 | Google Ads 数据约 30 万行 | L7D 分析生成可能超时，定时任务执行时间超过 1 小时 | ARCH-2 并发控制 + ARCH-4 退避重试 |
| 6 个月后 | Google Ads 数据约 60 万行 | SQLite 在并发写入时出现锁超时 | 需迁移到 PostgreSQL（ARCH-1 Alembic 支撑） |
| 1 年后 | 数据总量超 100 万行 | 需要数据归档策略、查询索引优化 | 长期规划 |

### 7.2 API 配额风险

| 场景 | 风险 | 对应方案 |
|------|------|---------|
| MCC 账号数量超过 10 个 | Explorer 配额不足 | SEC-9 速率限制 + ARCH-3 日期范围限制 |
| 配额短暂耗尽 | 定时任务失败，丢失当日数据 | ARCH-4 指数退避 + ARCH-2 互斥执行 |
| 升级到 Basic 级 | 需向 Google 申请（2-4 周） | 提前规划申请 |

### 7.3 安全风险演变

| 时间 | 风险 | 对应方案 |
|------|------|---------|
| 现在 | Git 仓库中含敏感 Token | SEC-2/SEC-3 Token 轮换 |
| 现在 | SECRET_KEY 可能为默认值 | SEC-5 启动校验 |
| 现在 | localStorage Token 可被 XSS 窃取 | SEC-7 内存化 |
| 被攻击时 | 多个漏洞可叠加放大 | 全部 SEC 修复 |

---

## 八、工作量汇总

### 8.1 按优先级统计（v7.2 更新）

| 优先级 | 项数 | 开发工时 | 联调测试工时 | 合计 | 说明 |
|--------|------|---------|------------|------|------|
| P0 阻塞上线 | 5 项 | **6.5h** | **1.5h** | **8h** | SEC-4(1.5h) + SEC-5b(0.5h) + SEC-1(1h) + DES-8(3h) + DES-2(0.5h) + 联调测试(1.5h) |
| P1 上线前 | 5 项 | **8.5h** | **2h** | **10.5h** | SEC-7(4h，含跨标签页协调) + SEC-6(0.5h) + SEC-2/3(1.5h) + ARCH-2(1h) + SEC-8(1.5h) + 联调测试(2h) |
| P2 近期 | 10 项 | **8.3h** | **2h** | **10.3h** | SEC-12(0.5h) + DES-6(0.5h) + DES-7(0.5h) + ARCH-1(2h) + ARCH-3(0.5h) + SEC-9(1h) + DES-1(1.5h) + DES-3(0.1h) + CODE-1/2(0.2h) + 赘余文件(2h) + CORS回归测试+清理后全量测试(2h) |
| P3 后续 | 6 项 | **6.7h** | - | **6.7h** | SEC-10(0.3h) + SEC-11(0.3h) + ARCH-4(1h) + ARCH-5(3h) + ARCH-6(2h) + DES-4(0.1h) |
| **总计** | **26 项** | **30h** | **5.5h** | **约 35.5h** | v7.2 新增联调测试工时（应审核报告 DOC-4） |

### 8.2 按修改范围统计

| 范围 | 涉及文件 | 修改项 |
|------|---------|--------|
| 后端配置层 | `config.py`, `main.py` | SEC-5, SEC-6, SEC-12, DES-4 |
| 后端权限层 | `auth.py`, `mcc.py`, `luchu_reviews.py` | SEC-4, DES-8, DES-6 |
| 后端数据层 | `dashboard.py`, `scheduler.py` | DES-2/CODE-5, ARCH-2 |
| 后端新增 | `backup_service.py`, `rate_limiter.py` | SEC-8, SEC-9 |
| 前端 | `authStore.js`, `api.js`, `App.jsx` | SEC-7, SEC-1(适配) |
| 脚本/文件清理 | 80+ 文件 | SEC-2/SEC-3, 赘余文件 |
| 架构变更 | Alembic 配置 | ARCH-1 |

---

## 九、业务问题确认记录

| 序号 | 问题 | 影响的修复项 | 07 的回答 | 方案调整 |
|------|------|------------|-----------|---------|
| 1 | 经理/组长在露出功能中的角色？ | DES-8 | **只有 wj07 和 wj02 能审核**；3-4月审核后发布，之后自审即发 | DES-8 完全重写：从 manager/leader 角色审核改为 wj07+wj02 专人审核 + 分阶段发布 |
| 2 | 组长审核范围？ | DES-8 | **仅本组** | 组过滤逻辑需在审核列表中实现（当前不涉及组长审核，此约束留作未来扩展参考） |
| 3 | jy/yz 组是否需要露出功能？ | DES-6 | **视情况，可能需要** | DES-6 改为配置化，支持通过环境变量动态添加用户 |
| 4 | 密码重置方式？ | SEC-1 | **经理指定** | SEC-1 改为必填 new_password 参数，移除随机生成逻辑 |
| 5 | Developer Token 能否轮换？ | SEC-2 | **不可以，继续使用原 Token** | SEC-2 轮换方案取消，改为检查仓库可见性 + 条件性 BFG 清理 |
| 6 | SECRET_KEY 是否已配置？ | SEC-5 | **不了解此概念**（已解释） | SEC-5 补充通俗解释 + 服务器检查命令，**待 07 执行检查后回复** |

### 已确认的紧急事项

| 序号 | 问题 | 确认结果 | 处理状态 |
|------|------|---------|---------|
| 6 | SECRET_KEY 当前值是否安全？ | ❌ 原为默认不安全值 | ✅ **已修复并验证**：密钥已替换，服务已重启，health 检查通过 |

---

## 十、审核清单（v7.2 更新）

### 第一轮审核整改（v7.0-v7.1）

| 序号 | 检查项 | 状态 |
|------|--------|------|
| 1 | 审核报告 14 项遗漏风险已全部编写方案 | ✅ 26 项全覆盖 |
| 2 | 每项方案包含问题阐释+解决思路+最终方案 | ✅ P0-P2 全部三要素完整 |
| 3 | 蝴蝶效应分析 + 修复顺序依赖图 | ✅ 已补充 |
| 4 | 前瞻性风险评估（数据量/配额/安全） | ✅ 已补充 |
| 5 | 6 个业务问题确认并落实到方案 | ✅ 全部确认 |
| 6 | SEC-5a 服务器密钥替换 | ✅ 已修复并验证 |

### 第二轮审核整改（v7.2）

| 序号 | 审核发现 | 修正状态 |
|------|---------|---------|
| 缺陷 1 | DES-8 伪代码 status 值错误 | ✅ 修正为 `"pending"`，与 `luchu.py:59` 模型一致 |
| 缺陷 2 | DES-8 发布接口权限未明确方案 | ✅ 补全发布接口修复步骤 9a-9c |
| 缺陷 3 | SEC-5 状态标注自相矛盾 | ✅ 拆分为 SEC-5a(已完成) + SEC-5b(待实施) |
| 疏漏 1 | DES-8 存量 pending 文章迁移 | ✅ 增加步骤 10-11 |
| 疏漏 2 | ARCH-2 threading.Lock 单进程假设 | ✅ 标注约束 + 多 worker 替代方案 |
| 疏漏 3 | SEC-7 多标签页与 SEC-10 冲突 | ✅ 增加 BroadcastChannel 协调方案 |
| 疏漏 4 | DES-2 safe_number 未覆盖边界值 | ✅ 增强：N/A、null、空字符串、会计格式负数 |
| 疏漏 5 | DES-8 自审模式缺少审计追溯 | ✅ 增加 `review_type` 字段（self/peer） |
| DOC-1 | 引用错误 "SEC-46" | ✅ 修正为"审核报告第 46 项验证" |
| DOC-2 | 附录 B/C 引用断裂 | ✅ 恢复功能核查清单摘要 |
| DOC-3 | 依赖图 SEC-5 状态未更新 | ✅ 拆分为 SEC-5a(已完成) + SEC-5b |
| DOC-4 | 工时缺少联调测试时间 | ✅ 增加 5.5h 联调测试工时，总工时 30h→35.5h |
| 额外 | SEC-4 枚举值已由审核代为确认 | ✅ 纳入方案，消除最大不确定性 |

---

*本设计方案 v7.2 为第二轮审核整改版。在 v7.1 基础上，修正了审核报告发现的 3 项方案缺陷（DES-8 status 值/发布接口/SEC-5 拆分）、5 项技术疏漏（存量文章迁移/ARCH-2 单进程约束/SEC-7 多标签页协调/DES-2 边界值/审计追溯）和 4 项文档问题（引用错误/附录断裂/依赖图/联调工时）。纳入了审核已确认的 UserRole 枚举值（MANAGER="manager"），SEC-4 最大不确定性已消除。共 27 项修复方案（SEC-5 拆分为 5a+5b），开发工时 30h + 联调测试 5.5h = 总计约 35.5h。SEC-5a 已完成，其余按修复依赖图顺序实施。*

---

## 附录 A：系统概况（沿用 v6.4）

| 项目 | 说明 |
|------|------|
| 项目名称 | Google Ads 数据分析平台 |
| 前端技术 | React 18 + Vite + Ant Design 5 |
| 后端技术 | FastAPI + SQLAlchemy + SQLite/PostgreSQL |
| 前端部署 | Cloudflare Pages |
| 后端部署 | 云服务器 (uvicorn) |
| GitHub | https://github.com/starrats111/Google-Data-Analysis |
| API 域名 | https://api.google-data-analysis.top |
| 前端域名 | https://google-data-analysis.top |
| 后端 API 路由文件 | 34 个 |
| 后端 API 端点 | 约 150+ 个 |
| 前端页面组件 | 36 个（3 个未注册路由） |
| 后端脚本 | 121+ 个（大部分为一次性修复脚本） |
| 数据模型 | 20+ 个 SQLAlchemy 模型 |
| 定时任务 | 4 个定时任务（v6.4 重构后） |

### 用户角色体系（v6.1 修正）

| 角色 | 英文 | 用户名 | 数量 | 权限范围 |
|------|------|--------|------|---------|
| 经理 | MANAGER | `manager` | 1 个 | 查看/编辑/删除所有数据 |
| 组长 | LEADER | `wjzu`, `jyzu`, `yzzu` | 3 个 | 查看/编辑/删除本组数据 |
| 组员 | MEMBER | `wj01`-`wj10`, `jy01`-`jy10`, `yz01`-`yz10` | 30 个 | 仅查看/编辑自己的数据 |
| 员工 | EMPLOYEE | （兼容旧数据） | - | 等同 MEMBER |

**小组结构**:

| 小组 | 组长 | 组员 |
|------|------|------|
| wj 组（文俊组） | `wjzu` | `wj01` - `wj10` |
| jy 组 | `jyzu` | `jy01` - `jy10` |
| yz 组 | `yzzu` | `yz01` - `yz10` |

---

## 附录 B：全系统功能核查清单（沿用 v6.4，v7.2 标注）

> v7.2 修正（应审核报告 DOC-2）：v6.4 原文已被后续版本覆盖。以下为功能核查清单摘要，完整 A-T 共 20 个模块详见 v6.4 版本 Git 历史（commit 中搜索"v6.4 定时任务重构"）。

**核查清单摘要**（A-T 共 20 个模块，约 120 个功能项）：

| 模块 | 编号 | 项数 | 关键问题 |
|------|------|------|---------|
| A. 基础设施 | A1-A4 | 4 | DES-1 CORS 四重冗余、CODE-2 配置重复 |
| B. 认证与用户 | B1-B6 | 6 | SEC-1 密码硬编码 |
| C. MCC 管理 | C1-C8 | 8 | SEC-4 wenjun123 硬编码 |
| D. 联盟平台 | D1-D7 | 7 | D6/D7 专用 API 赘余 |
| E. Google Ads | E1-E4 | 4 | - |
| F. 平台数据 | F1-F4 | 4 | - |
| G. 数据分析 | G1-G7 | 7 | DES-3 废弃端点 |
| H. 出价管理 | H1-H12 | 12 | - |
| I. 仪表板 | I1-I6 | 6 | DES-2/CODE-5 platform-summary 500 |
| J. 费用管理 | J1-J5 | 5 | - |
| K. 报告模块 | K1-K7 | 7 | - |
| L. AI/Gemini | L1-L9 | 9 | - |
| M. 文件上传 | M1-M3 | 3 | SEC-11 文件名清理 |
| N. 团队管理 | N1-N7 | 7 | - |
| O. 数据导出 | O1-O2 | 2 | - |
| P. 系统管理 | P1-P3 | 3 | - |
| Q. 露出功能 | Q1-Q18 | 18 | DES-8 审核死锁、DES-6 权限 |
| R. Google OAuth | R1-R2 | 2 | DES-7 已弃用 |
| S. 阶段标签 | S1 | 1 | - |
| T. 广告系列 | T1-T5 | 5 | - |

**前端页面**：33 个已注册路由 + 3 个废弃页面（Upload/Expenses/MyAnalysis）+ 1 个弃用页面（GoogleOAuthCallback）

**赘余文件**：根目录 20 个 + scripts/ 60+ 个，详见 v6.4 第五节清理清单

---

## 附录 C：自动化测试结果（沿用 v6.4）

| 轮次 | 总计 | PASS | FAIL | WARN | 通过率 |
|------|------|------|------|------|--------|
| 第一轮 (v6.2) | 87 | 71 | 16 | - | 81.6% |
| 第二轮 (v6.3) | 85 | 81 | 3 | 1 | 95.3% |
| 第三轮 (v6.3+) | 85 | 82 | 1 | 2 | 96.5% |

---

## 附录 D：定时任务核查（沿用 v6.4）

| 编号 | 任务名 | 执行时间 | 状态 |
|------|--------|---------|------|
| CRON-1 | 每日自动同步与分析 | 每天 04:00 | ✅ 正常 |
| CRON-2 | 历史数据自动补齐 | 每天 05:00 | ✅ 新增(v6.4) |
| CRON-3 | 平台数据补充同步 | 每天 16:00 | ✅ 正常 |
| CRON-4 | 已付佣金同步 | 每月 1/15 号 00:00 | ✅ 正常 |

---

## 附录 E：v5.4 遗留问题状态（沿用 v6.4）

| 编号 | 问题 | 是否已实施 |
|------|------|-----------|
| D1 CNY 双重转换 | ✅ 已实施 |
| D1补 清理脚本 | ⚠️ 待确认执行状态 |
| D2 拒付佣金 | ✅ 已实施 |
| D3 L7D 系列数量 | ✅ 已实施 |
| D5 IS >90% | ✅ 已实施 |
| D6 Max CPC | ✅ 已实施 |
| P1 Playwright 超时 | ✅ 已实施 |
| P2 SVG 缓存 | ✅ 已实施 |
| P2补 代理日志 | ⚠️ 部分实施 |
